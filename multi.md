## שאלה 20: מה תהיה תוצאת הריצה של הקוד הבא מבחינת ניהול זיכרון
```python
class A:
    def __init__(self):
        self.b = None

class B:
    def __init__(self):
        self.a = None

a = A()
b = B()
a.b = b
b.a = a
```
א. שני האובייקטים יימחקו מיד בסיום הסקריפט כי אין עליהם רפרנס

ב. שני האובייקטים יישארו בזיכרון כי יש ביניהם הפניה מעגלית

ג. האובייקטים יוחזרו ל־pool של memory reuse

ד. תיזרק שגיאה בגלל רפרנס לא קיים# מבחן אמריקאי – OOP ונושאים מתקדמים בפייתון

## שאלה 1: מהו תפקיד המתודה __init__ במחלקת פייתון
א. ליצור מופע חדש של המחלקה ולבצע בו אתחול של משתנים

ב. להחזיר מחרוזת שמייצגת את האובייקט

ג. להוסיף שני אובייקטים באמצעות הסימן +

ד. לקרוא לקובץ חיצוני ולייבא נתונים

## שאלה 2: מה ההבדל המרכזי בין @staticmethod ל־@classmethod בפייתון
א. @staticmethod חייב לקבל את הפרמטר self ו־@classmethod לא

ב. @classmethod מקבל את המחלקה כפרמטר ראשון (cls), ו־@staticmethod לא מקבל אובייקט בכלל

ג. @staticmethod לא ניתן לקרוא מתוך מופע של המחלקה

ד. @classmethod חייב להחזיר מופע חדש של המחלקה

## שאלה 3: מהי מטרת השיטה __str__ במחלקת פייתון
א. לבצע השוואה בין שני אובייקטים

ב. להחזיר ייצוג טקסטואלי של האובייקט כשמדפיסים אותו

ג. לאתחל משתנים במחלקה

ד. להמיר את האובייקט לקובץ JSON

## שאלה 4: מה קורה כאשר מפעילים את האופרטור == על שני מופעים מאותה מחלקה בלי להגדיר את __eq__
א. תתקבל שגיאה מסוג TypeError

ב. ההשוואה תתבצע לפי תוכן המשתנים בכל מופע

ג. ההשוואה תתבצע לפי כתובת הזיכרון של המופעים

ד. פייתון תשתמש ב־__cmp__ כברירת מחדל

## שאלה 5: מה נדרש כדי להפוך מחלקה לאיטרטור בפייתון
א. לממש רק את המתודה __next__

ב. לממש את המתודות __iter__ ו-__next__

ג. לממש רק את המתודה __iter__

ד. לרשת מהמחלקה Iterator

## שאלה 6: מהו __hash__ ואיזה תפקיד הוא ממלא
א. מחזיר את האורך של מחרוזת באובייקט

ב. מחזיר ערך מספרי ייחודי שמייצג את האובייקט עבור שימוש במבני נתונים כמו dict או set

ג. מבצע הצפנה על האובייקט

ד. משווה בין שני אובייקטים באמצעות סכום הספרות של מזהה האובייקט

## שאלה 7: מה מאפשרת המתודה __add__ כאשר היא מוגדרת במחלקה
א. שימוש באופרטור + בין מופעים של המחלקה בלבד

ב. שימוש באופרטור + בין מופע של המחלקה לכל אובייקט שתואם את הלוגיקה שבמתודה

ג. המרה אוטומטית של האובייקט למספר שלם

ד. השוואת כתובות זיכרון בין מופעים

## שאלה 8: מה יקרה אם נממש __eq__ אך לא נממש __hash__ וננסה להשתמש במופע של המחלקה כ־key במילון (dict)
א. תתקבל שגיאה מסוג KeyError

ב. המופע ישמש כמפתח לפי ה־id שלו

ג. תתקבל שגיאה מסוג TypeError

ד. הערך יאוחסן אך לא ניתן יהיה לעדכן אותו

## שאלה 9: מה היתרון המרכזי בשימוש במחלקה מופשטת (abstract base class) בפייתון
א. היא מקצרת את זמן הריצה של הקוד

ב. היא מאפשרת ליצור מופעים ישירות ולרשת מכל מחלקה אחרת

ג. היא מגדירה ממשק מחייב למחלקות שיורשות ממנה

ד. היא מונעת ירושה ממחלקות אחרות

## שאלה 10: מה יקרה אם ננסה ליצור מופע ממחלקה שמוגדרת כ־abstract ויש בה מתודה אחת abstract שלא מומשה
א. תתקבל שגיאה בזמן ריצה

ב. תתקבל שגיאה בזמן הידור

ג. תתקבל שגיאה בזמן יצירת מופע

ד. הקוד ירוץ אך המתודה תחזיר None

## שאלה 11: מהי התוצאה של ניסיון לרשת ממחלקה שמסומנת כ־abstract אך לא לממש את כל המתודות ה־abstract
א. הקוד ירוץ אך לא יהיה ניתן לקרוא למתודות ה־abstract

ב. תתקבל שגיאה בזמן יצירת מופע מהמחלקה היורשת

ג. תתקבל שגיאה מיד כשנטען הקובץ

ד. פייתון תשתמש במימוש ברירת מחדל של המתודות החסרות

## שאלה 12: מה קורה כאשר שני threads ניגשים לאותו משתנה בזיכרון בלי סנכרון מתאים
א. אחד מהם ייחסם אוטומטית עד שהשני יסיים

ב. תתקבל שגיאה מסוג MemoryAccessError

ג. התוצאה עלולה להיות לא צפויה בגלל מצב של race condition

ד. המערכת תסיים את אחד מה־threads כדי למנוע שגיאה

## שאלה 13: מה ההבדל בין *args ל־**kwargs בפייתון
א. *args אוסף מחרוזות ו־**kwargs אוסף מספרים

ב. *args משמש לארגומנטים לפי מפתח ו־**kwargs לפי מיקום

ג. *args אוסף ארגומנטים לפי מיקום ו־**kwargs אוסף ארגומנטים לפי מפתח

ד. אין הבדל – שניהם מתפקדים באותו אופן

## שאלה 14: למה משמשת המתודה __hash__ בפייתון
א. כדי ליצור מזהה ייחודי לכל מופע לצורך השוואה

ב. כדי לאפשר שימוש באובייקט כמפתח במילון או כחבר בקבוצת set

ג. כדי להמיר מופע למחרוזת

ד. כדי להבטיח שכל מופע יהיה שונה ממופע אחר בזיכרון

## שאלה 15: מהי המשמעות של GIL (Global Interpreter Lock) בפייתון
א. מאפשר לפייתון להריץ כמה threads בו־זמנית על ליבות שונות

ב. מגביל את פייתון כך שרק thread אחד יכול להריץ קוד פייתון בכל רגע נתון

ג. נועל את הקוד שלך כדי למנוע גישה מריבוי משתמשים

ד. חלק ממנגנון הגיבוי של זיכרון בתוכנית

## שאלה 16: מה היתרון המרכזי של שימוש ב־logging על פני print בפייתון
א. logging מהיר יותר משמעותית מ־print

ב. logging יכול להחליף את כל השימושים ב־try-except

ג. logging מאפשר רמות דיווח שונות וכתיבה לקובץ או קונסולה

ד. print לא עובד בתוך פונקציות של מחלקות

## שאלה 17: מה תהיה תוצאת הריצה של הקוד הבא
```python
try:
    result = 10 / 0
except ValueError:
    print("Value error")
finally:
    print("Done")
```
א. יודפס רק "Done"

ב. יודפס "Value error" ואז "Done"

ג. יודפס "Done" ואז תיזרק שגיאת ZeroDivisionError כי אין except מתאים

ד. לא יודפס כלום כי התוכנית נתקעת לפני ה־finally

## שאלה 18: הקוד הבא רץ לאט וצורך הרבה זיכרון
```python
def process():
    data = create_big_list()
    doubled = double_values(data)
    return sum(doubled)
```
מהי הדרך הכי טובה לזהות איזו מהפונקציות create_big_list או double_values אחראית לצריכת זיכרון גבוהה
א. להוסיף print(len(data)) כדי לבדוק את גודל הרשימה

ב. להשתמש ב־timeit כדי למדוד את זמן הריצה של כל פונקציה

ג. להשתמש ב־memory_profiler עם @profile כדי למדוד שימוש בזיכרון

ד. להוסיף gc.collect() בכל שורה כדי לנקות את הזיכרון

## שאלה 19: מהו מצב של cycle reference בפייתון
א. מצב שבו פונקציה קוראת לעצמה בלי תנאי עצירה

ב. מצב שבו שני אובייקטים מחזיקים הפניה אחד לשני, כך שלא ניתן לפנות את הזיכרון

ג. מצב שבו לולאה לא נגמרת ונתקעת לנצח

ד. מצב שבו משתנה משמש גם כמפתח וגם כערך באותו מילון

## שאלה 20: מה תהיה תוצאת הריצה של הקוד הבא מבחינת ניהול זיכרון
```python
class A:
    def __init__(self):
        self.b = None

class B:
    def __init__(self):
        self.a = None

a = A()
b = B()
a.b = b
b.a = a
```
א. שני האובייקטים יימחקו מיד בסיום הסקריפט כי אין עליהם רפרנס  
ב. שני האובייקטים יישארו בזיכרון כי יש ביניהם הפניה מעגלית  
ג. האובייקטים יוחזרו ל־pool של memory reuse  
ד. תיזרק שגיאה בגלל רפרנס לא קיים  

## שאלה 21: יש לך שני קבצים: module_a.py ו־module_b.py, שכל אחד מהם מייבא פונקציה מהשני
בעת הרצה אתה מקבל שגיאת ImportError או AttributeError בגלל הפניה מעגלית

מהו פתרון מקובל כדי למנוע הפניה מעגלית ועדיין להשתמש בפונקציה מהמודול השני
א. לא להשתמש בכלל ב־import

ב. לשים את ה־import בתוך הפונקציה שזקוקה לו

ג. להריץ את הקובץ דרך קומפיילר חיצוני

ד. להכניס את שתי הפונקציות לאותו קובץ

## שאלה 22: מהי המשמעות של Reference Count בפייתון
א. מספר הפעמים שאובייקט שונה את ערכו

ב. מספר המשתנים שמצביעים על אותו אובייקט בזיכרון

ג. מספר הפעמים שפונקציה נקראת

ד. מספר השורות בהן מופיע האובייקט

## שאלה 23: למה משמשת Weak Reference בפייתון
א. היא מאפשרת לשכפל אובייקט בזיכרון מבלי לשנות את ה־ref count

ב. היא מחזיקה הפניה לאובייקט בלי למנוע מה־garbage collector למחוק אותו

ג. היא יוצרת עותק זמני של אובייקט שלא נשמר בזיכרון

ד. היא משפרת את הביצועים של פונקציות רקורסיביות

## שאלה 24: מה היתרון בהגדרת תכונה כ־private עם __name ושימוש ב־getter ו־setter עבורה
א. מאפשר גישה לתכונה גם מתוך מחלקות אחרות באופן אוטומטי

ב. מאפשר ליצור שם קצר יותר לתכונה בזמן הריצה

ג. מאפשר שליטה על גישה, אימות ולוגיקה לפני קריאה או שינוי של הערך

ד. מאפשר לתכונה להישמר בזיכרון גם אחרי שהאובייקט נמחק

## שאלה 25: למה נשתמש ב־multiprocessing במקום ב־threading בפייתון
א. כי multiprocessing תומך ביותר פלטפורמות

ב. כי multiprocessing צורך פחות זיכרון לכל תהליך

ג. כי multiprocessing עוקף את מגבלת ה־GIL ולכן מתאים לעומסים חישוביים

ד. כי multiprocessing רץ רק על תהליכונים ולא על לולאות
