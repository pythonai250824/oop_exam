
# מימוש מחלקות קלפי משחק
## מטרת המשימה
לממש מערכת של קלפי משחק בפייתון תוך שימוש בתכנות מונחה עצמים, הכוללת שימוש ב-Enum, property decorators, custom decorators, iterators ואופרטורים מובנים (dunder methods)

<img src="deck_exam2.png">

## דרישות המשימה

### מחלקת `Card`
1. שדות:
   - `_suit`: סוג הקלף (מסוג `CardSuit`)
   - `_rank`: הערך של הקלף (מסוג `CardRank`)
2. מתודות:
   - `__init__(suit, rank)`: בנאי המקבל סוג קלף, ערך
   - `suit` (@property): מחזיר את סוג הקלף (property לקריאה בלבד)
   - `rank` (@property): מחזיר את ערך הקלף (property לקריאה בלבד)
   - `get_display_name()`: מחזיר את שם הקלף בפורמט מתאים (למשל: "Ace of Spades", "Jack of Hearts")
3. אופרטורים (dunder methods):
   - `__eq__(other)`: בודק אם שני קלפים שווים (אותו ערך וסוג)
   - `__lt__(other)`: בודק אם הקלף הנוכחי נמוך יותר מהקלף האחר (לפי ערך תחילה, אם ערך זהה אז לפי סוג)
   - `__gt__(other)`: בודק אם הקלף הנוכחי גבוה יותר מהקלף האחר (לפי ערך תחילה, אם ערך זהה אז לפי סוג)
   - `__hash__()`: מחזיר hash code המבוסס על הסוג והערך של הקלף
   - `__str__()`: מחזיר את ייצוג הקלף כמחרוזת
   - `__repr__()`: מחזיר ייצוג מפורט של הקלף לצורכי debugging

## מחלקת `Deck`
1. שדות:
   - `_cards`: רשימה של הקלפים בחפיסה
2. מתודות:
   - `__init__(shuffle=True)`: בנאי שיוצר חפיסה שלמה של 52 קלפים, עם אפשרות לערבב אותה
   - `cards` (@property): מחזיר עותק של רשימת הקלפים בחפיסה (property לקריאה בלבד)
   - `shuffle()`: מערבבת את הקלפים בחפיסה 
   - `draw()`: שולפת ומסירה קלף מראש החפיסה(או None אם החפיסה ריקה)
   - `add_card(card)`: מוסיפה קלף לחפיסה
3. אופרטורים (dunder methods):
   - `__len__()`: מחזיר את מספר הקלפים בחפיסה
   - `__getitem__(index)`: מאפשר גישה לקלף מסוים בחפיסה לפי אינדקס (ללא הסרתו מהחפיסה)
   - `__iter__()`: איטרטור
   - __max__: מחזיר את הקלף הגבוה ביותר בחפיסה
   - __min__: מחזיר את הקלף הנמוך ביותר בחפיסה

## הנחיות מימוש ה-חוזה
1. צור מחלקה של חוזה עם פונקציות אבסטרקטיות אותה יממש DECK
2. צור מחלקה של חוזה עם פונקציות אבסטרקטיות אותה יממש CARD 
   
## הנחיות נוספות
1. סוג הקלף והערך שלו הם לקריאה בלבד (read-only), כלומר אין אפשרות לשנות אותם ישירות.
2. השוואה בין קלפים מתבצעת לפי חוקי הפוקר הסטנדרטיים (ערך גבוה יותר מנצח, אם הערך שווה אז סוג הקלף קובע).
3. יש לטפל במקרים של שגיאות (למשל השוואה בין קלף לאובייקט מסוג אחר).
4. הערך היחסי של סוגי הקלפים הוא: SPADES > HEARTS > DIAMONDS > CLUBS.

# גישה ישירה לקלפים לפי אינדקס באמצעות __getitem__
```
print("Accessing cards directly by index:")
for i in range(5):
    print(f"Card at index {i}: {deck[i]}")
```

# מעבר על כל הקלפים בחפיסה באמצעות האיטרטור
```
print("Iterating through all cards in the deck:")
for card in deck:
    print(card)
```

### Custom Exception
יש ליצור exception בשם `DeckCheatingError` שמשמש לזיהוי מקרים בהם קיים חשד למניפולציה של חפיסת קלפים

### Decorator `fair_deck` -- בונוס
1. יש לממש decorator בשם `fair_deck` שמטרתו לוודא שפונקציות המחזירות חפיסות קלפים ומוסיפות קלף חוקיות
2. ה-decorator יפעיל את הפונקציה המקושטת ויבדוק שאין את אותו הקלף פעמיים
 
### מחלקת `CardSuit` (Enum) -- בונוס
1. יש ליצור Enum שמייצג את סוגי הקלפים השונים: HEARTS, DIAMONDS, CLUBS, SPADES
2. כל סוג קלף מייצג את הערך היחסי שלו במשחק (למשל SPADES = 4, HEARTS = 3, וכו')

### מחלקת `CardRank` (Enum) -- בונוס
1. יש ליצור Enum שמייצג את ערכי הקלפים: TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING, ACE

### פונקציה max_card
צור פונקציה המקבלת קלפים ב *args ומחזירה את הקלף הגבוה ביותר

### פונקציה cards_stats -- בונוס
צור פונקציה המקבלת קלפים ב *args ובקשות ב **kwargs
כלומר אם ב kwargs יופיע max יוחזר הקלף הכי גבוה, min הכי נמוך, len יוחזר תוחזר גודל החפיסה
לדוגמא עבור: {max: 2, min: 1, len: 1} יוחזרו 2 הקלפים הכי גבוהים, הקלף הכי נמוך, וגודל החפיסה 

## הגשה
1. יש להגיש קובץ Python אחד הכולל את כל המחלקות, ה-decorator ופונקציית `main` עם תיעוד מלא (docstrings)
2. יש להדגים:
   - פעולות בסיסיות: צור חפיסה, הדפס אותה, משוך קלף והדפס אותו, הוסף קלף
   - שימוש בגישה ישירה לקלפים באמצעות אופרטור האינדקס (כלומר `deck[i]`)
   - מעבר על כל הקלפים באמצעות לולאת for (באמצעות האיטרטור שמימשתם)
4. בונוס -- יש להדגים את השימוש ב-decorator `fair_deck` עם פונקציית פרופרטי `cards`, ו- `add_card`
5. יש לוודא שכל הדרישות לעיל מיושמות במלואן

בהצלחה!
